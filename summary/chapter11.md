# Chapter 11 병행성과 네트워크

* 여러 장소 (분산 컴퓨팅 혹은 네트워킹) 에서 동시에 여러 개의 일 (병행성) 을 수행 가능
  * 이것이 좋은 이유?
    1. 성능(performance): 느린 요소를 기다리지 X, 빠른 요소를 바쁘게 유지
    2. 견고함(robustness): 작업을 복제해 여러가지 안정적인 방식으로 운영
    3. 간소화(simplicity): 복잡한 작업 → 해결하기 쉬운 여러 작은 작업으로
    4. 커뮤니케이션(communication): 데이터 (바이트) 를 보내고 싶은 곳에 원격 전송 / 수신



### 11.1 병행성

* 컴퓨터가 수행 대기하는 경우

  1. I/O 바운드: I/O 대기에 대부분을 보내는 수행상태
  2. CPU 바운드: CPU 연산에 대부분을 보내는 수행상태

  ~~~
  * 병행성 관련 용어
  1) 동기(synchronous): 한 작업은 다른 작업을 따른다
  2) 비동기(asynchronous): 작업들이 독립적
  ~~~



1. 큐(Queue)

   * 일반적으로 FIFO(First In First Out)
   * 큐는 메시지를 전달한다

2. 프로세스

3. 스레드

   : 한 프로세스 내에서 실행, 프로세스의 모든 자원에 접근 가능

   * 전역 데이터가 관여하지 않을때 유용하고 안전
     → 스레드를 사용하려면 프로그램의 모든 코드와 이 프로그램을 사용하는 외부 라이브러리에서 반드시 스레드-세이프 한 코드를 작성해야 함

   ~~~
   * multiprocessing 모듈 → 여기서 스레드는 threading
   * Pool은 말 그대로 처리할 일(inputs)들을 바닥에 뿌려놓고 알아서 분산 처리를 하게 만드는 것이고 Process는 각 프로세스별로 할당량을 명시적으로 정해준 뒤 일을 맡기는 것
   
   - Daemon Thread : 일반적으로는 메인이 죽으면 같이 죽는 쓰레드, 디폴트는 nondaemon
   - Locks (ex. Process(target=printer, args=(item, lock)) )
   		: 프로세스가 서로 간섭하지 않도록 Lock 객체를 사용, 다음 라인의 프로세스는 계속하기 전에 잠금이 해제 될 때까지 기다림
   ~~~

   

-- 다시 앞에서부터 보기